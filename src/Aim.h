/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Aim_H
#define Aim_H

#include <thrift/TDispatchProcessor.h>
#include "aim_types.h"



class AimIf {
 public:
  virtual ~AimIf() {}
  virtual void checkRimpConfiguration() = 0;
  virtual int64_t getDiskFileSize(const std::string& virtualImageDatastorePath) = 0;
  virtual void getDatastores(std::vector<Datastore> & _return) = 0;
  virtual void getNetInterfaces(std::vector<NetInterface> & _return) = 0;
  virtual void copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID) = 0;
  virtual void deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID) = 0;
  virtual void copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath) = 0;
  virtual void createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) = 0;
  virtual void deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) = 0;
  virtual void checkVLANConfiguration() = 0;
  virtual void getInitiatorIQN(std::string& _return) = 0;
  virtual void rescanISCSI(const std::vector<std::string> & targets) = 0;
  virtual void getNodeInfo(NodeInfo& _return) = 0;
  virtual void getDomains(std::vector<DomainInfo> & _return) = 0;
  virtual void defineDomain(const std::string& xmlDesc) = 0;
  virtual void undefineDomain(const std::string& domainName) = 0;
  virtual bool existDomain(const std::string& domainName) = 0;
  virtual DomainState::type getDomainState(const std::string& domainName) = 0;
  virtual void getDomainInfo(DomainInfo& _return, const std::string& domainName) = 0;
  virtual void powerOn(const std::string& domainName) = 0;
  virtual void powerOff(const std::string& domainName) = 0;
  virtual void reset(const std::string& domainName) = 0;
  virtual void pause(const std::string& domainName) = 0;
  virtual void resume(const std::string& domainName) = 0;
  virtual void createISCSIStoragePool(const std::string& xmlDesc) = 0;
  virtual void createNFSStoragePool(const std::string& xmlDesc) = 0;
  virtual void resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb) = 0;
};

class AimIfFactory {
 public:
  typedef AimIf Handler;

  virtual ~AimIfFactory() {}

  virtual AimIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(AimIf* /* handler */) = 0;
};

class AimIfSingletonFactory : virtual public AimIfFactory {
 public:
  AimIfSingletonFactory(const boost::shared_ptr<AimIf>& iface) : iface_(iface) {}
  virtual ~AimIfSingletonFactory() {}

  virtual AimIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(AimIf* /* handler */) {}

 protected:
  boost::shared_ptr<AimIf> iface_;
};

class AimNull : virtual public AimIf {
 public:
  virtual ~AimNull() {}
  void checkRimpConfiguration() {
    return;
  }
  int64_t getDiskFileSize(const std::string& /* virtualImageDatastorePath */) {
    int64_t _return = 0;
    return _return;
  }
  void getDatastores(std::vector<Datastore> & /* _return */) {
    return;
  }
  void getNetInterfaces(std::vector<NetInterface> & /* _return */) {
    return;
  }
  void copyFromRepositoryToDatastore(const std::string& /* virtualImageRepositoryPath */, const std::string& /* datastorePath */, const std::string& /* virtualMachineUUID */) {
    return;
  }
  void deleteVirtualImageFromDatastore(const std::string& /* datastorePath */, const std::string& /* virtualMachineUUID */) {
    return;
  }
  void copyFromDatastoreToRepository(const std::string& /* virtualMachineUUID */, const std::string& /* snapshot */, const std::string& /* destinationRepositoryPath */, const std::string& /* sourceDatastorePath */) {
    return;
  }
  void createVLAN(const int32_t /* vlanTag */, const std::string& /* vlanInterface */, const std::string& /* bridgeInterface */) {
    return;
  }
  void deleteVLAN(const int32_t /* vlanTag */, const std::string& /* vlanInterface */, const std::string& /* bridgeInterface */) {
    return;
  }
  void checkVLANConfiguration() {
    return;
  }
  void getInitiatorIQN(std::string& /* _return */) {
    return;
  }
  void rescanISCSI(const std::vector<std::string> & /* targets */) {
    return;
  }
  void getNodeInfo(NodeInfo& /* _return */) {
    return;
  }
  void getDomains(std::vector<DomainInfo> & /* _return */) {
    return;
  }
  void defineDomain(const std::string& /* xmlDesc */) {
    return;
  }
  void undefineDomain(const std::string& /* domainName */) {
    return;
  }
  bool existDomain(const std::string& /* domainName */) {
    bool _return = false;
    return _return;
  }
  DomainState::type getDomainState(const std::string& /* domainName */) {
    DomainState::type _return = (DomainState::type)0;
    return _return;
  }
  void getDomainInfo(DomainInfo& /* _return */, const std::string& /* domainName */) {
    return;
  }
  void powerOn(const std::string& /* domainName */) {
    return;
  }
  void powerOff(const std::string& /* domainName */) {
    return;
  }
  void reset(const std::string& /* domainName */) {
    return;
  }
  void pause(const std::string& /* domainName */) {
    return;
  }
  void resume(const std::string& /* domainName */) {
    return;
  }
  void createISCSIStoragePool(const std::string& /* xmlDesc */) {
    return;
  }
  void createNFSStoragePool(const std::string& /* xmlDesc */) {
    return;
  }
  void resizeDisk(const std::string& /* domainName */, const std::string& /* diskPath */, const double /* diskSizeInKb */) {
    return;
  }
};


class Aim_checkRimpConfiguration_args {
 public:

  Aim_checkRimpConfiguration_args() {
  }

  virtual ~Aim_checkRimpConfiguration_args() throw() {}


  bool operator == (const Aim_checkRimpConfiguration_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_checkRimpConfiguration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkRimpConfiguration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_checkRimpConfiguration_pargs {
 public:


  virtual ~Aim_checkRimpConfiguration_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_checkRimpConfiguration_result__isset {
  _Aim_checkRimpConfiguration_result__isset() : re(false) {}
  bool re;
} _Aim_checkRimpConfiguration_result__isset;

class Aim_checkRimpConfiguration_result {
 public:

  Aim_checkRimpConfiguration_result() {
  }

  virtual ~Aim_checkRimpConfiguration_result() throw() {}

  RimpException re;

  _Aim_checkRimpConfiguration_result__isset __isset;

  void __set_re(const RimpException& val) {
    re = val;
  }

  bool operator == (const Aim_checkRimpConfiguration_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_checkRimpConfiguration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkRimpConfiguration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_checkRimpConfiguration_presult__isset {
  _Aim_checkRimpConfiguration_presult__isset() : re(false) {}
  bool re;
} _Aim_checkRimpConfiguration_presult__isset;

class Aim_checkRimpConfiguration_presult {
 public:


  virtual ~Aim_checkRimpConfiguration_presult() throw() {}

  RimpException re;

  _Aim_checkRimpConfiguration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_getDiskFileSize_args__isset {
  _Aim_getDiskFileSize_args__isset() : virtualImageDatastorePath(false) {}
  bool virtualImageDatastorePath;
} _Aim_getDiskFileSize_args__isset;

class Aim_getDiskFileSize_args {
 public:

  Aim_getDiskFileSize_args() : virtualImageDatastorePath() {
  }

  virtual ~Aim_getDiskFileSize_args() throw() {}

  std::string virtualImageDatastorePath;

  _Aim_getDiskFileSize_args__isset __isset;

  void __set_virtualImageDatastorePath(const std::string& val) {
    virtualImageDatastorePath = val;
  }

  bool operator == (const Aim_getDiskFileSize_args & rhs) const
  {
    if (!(virtualImageDatastorePath == rhs.virtualImageDatastorePath))
      return false;
    return true;
  }
  bool operator != (const Aim_getDiskFileSize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDiskFileSize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getDiskFileSize_pargs {
 public:


  virtual ~Aim_getDiskFileSize_pargs() throw() {}

  const std::string* virtualImageDatastorePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDiskFileSize_result__isset {
  _Aim_getDiskFileSize_result__isset() : success(false), re(false) {}
  bool success;
  bool re;
} _Aim_getDiskFileSize_result__isset;

class Aim_getDiskFileSize_result {
 public:

  Aim_getDiskFileSize_result() : success(0) {
  }

  virtual ~Aim_getDiskFileSize_result() throw() {}

  int64_t success;
  RimpException re;

  _Aim_getDiskFileSize_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  void __set_re(const RimpException& val) {
    re = val;
  }

  bool operator == (const Aim_getDiskFileSize_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_getDiskFileSize_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDiskFileSize_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDiskFileSize_presult__isset {
  _Aim_getDiskFileSize_presult__isset() : success(false), re(false) {}
  bool success;
  bool re;
} _Aim_getDiskFileSize_presult__isset;

class Aim_getDiskFileSize_presult {
 public:


  virtual ~Aim_getDiskFileSize_presult() throw() {}

  int64_t* success;
  RimpException re;

  _Aim_getDiskFileSize_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Aim_getDatastores_args {
 public:

  Aim_getDatastores_args() {
  }

  virtual ~Aim_getDatastores_args() throw() {}


  bool operator == (const Aim_getDatastores_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getDatastores_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDatastores_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getDatastores_pargs {
 public:


  virtual ~Aim_getDatastores_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDatastores_result__isset {
  _Aim_getDatastores_result__isset() : success(false), re(false) {}
  bool success;
  bool re;
} _Aim_getDatastores_result__isset;

class Aim_getDatastores_result {
 public:

  Aim_getDatastores_result() {
  }

  virtual ~Aim_getDatastores_result() throw() {}

  std::vector<Datastore>  success;
  RimpException re;

  _Aim_getDatastores_result__isset __isset;

  void __set_success(const std::vector<Datastore> & val) {
    success = val;
  }

  void __set_re(const RimpException& val) {
    re = val;
  }

  bool operator == (const Aim_getDatastores_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_getDatastores_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDatastores_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDatastores_presult__isset {
  _Aim_getDatastores_presult__isset() : success(false), re(false) {}
  bool success;
  bool re;
} _Aim_getDatastores_presult__isset;

class Aim_getDatastores_presult {
 public:


  virtual ~Aim_getDatastores_presult() throw() {}

  std::vector<Datastore> * success;
  RimpException re;

  _Aim_getDatastores_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Aim_getNetInterfaces_args {
 public:

  Aim_getNetInterfaces_args() {
  }

  virtual ~Aim_getNetInterfaces_args() throw() {}


  bool operator == (const Aim_getNetInterfaces_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getNetInterfaces_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNetInterfaces_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getNetInterfaces_pargs {
 public:


  virtual ~Aim_getNetInterfaces_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getNetInterfaces_result__isset {
  _Aim_getNetInterfaces_result__isset() : success(false), re(false) {}
  bool success;
  bool re;
} _Aim_getNetInterfaces_result__isset;

class Aim_getNetInterfaces_result {
 public:

  Aim_getNetInterfaces_result() {
  }

  virtual ~Aim_getNetInterfaces_result() throw() {}

  std::vector<NetInterface>  success;
  RimpException re;

  _Aim_getNetInterfaces_result__isset __isset;

  void __set_success(const std::vector<NetInterface> & val) {
    success = val;
  }

  void __set_re(const RimpException& val) {
    re = val;
  }

  bool operator == (const Aim_getNetInterfaces_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_getNetInterfaces_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNetInterfaces_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getNetInterfaces_presult__isset {
  _Aim_getNetInterfaces_presult__isset() : success(false), re(false) {}
  bool success;
  bool re;
} _Aim_getNetInterfaces_presult__isset;

class Aim_getNetInterfaces_presult {
 public:


  virtual ~Aim_getNetInterfaces_presult() throw() {}

  std::vector<NetInterface> * success;
  RimpException re;

  _Aim_getNetInterfaces_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_copyFromRepositoryToDatastore_args__isset {
  _Aim_copyFromRepositoryToDatastore_args__isset() : virtualImageRepositoryPath(false), datastorePath(false), virtualMachineUUID(false) {}
  bool virtualImageRepositoryPath;
  bool datastorePath;
  bool virtualMachineUUID;
} _Aim_copyFromRepositoryToDatastore_args__isset;

class Aim_copyFromRepositoryToDatastore_args {
 public:

  Aim_copyFromRepositoryToDatastore_args() : virtualImageRepositoryPath(), datastorePath(), virtualMachineUUID() {
  }

  virtual ~Aim_copyFromRepositoryToDatastore_args() throw() {}

  std::string virtualImageRepositoryPath;
  std::string datastorePath;
  std::string virtualMachineUUID;

  _Aim_copyFromRepositoryToDatastore_args__isset __isset;

  void __set_virtualImageRepositoryPath(const std::string& val) {
    virtualImageRepositoryPath = val;
  }

  void __set_datastorePath(const std::string& val) {
    datastorePath = val;
  }

  void __set_virtualMachineUUID(const std::string& val) {
    virtualMachineUUID = val;
  }

  bool operator == (const Aim_copyFromRepositoryToDatastore_args & rhs) const
  {
    if (!(virtualImageRepositoryPath == rhs.virtualImageRepositoryPath))
      return false;
    if (!(datastorePath == rhs.datastorePath))
      return false;
    if (!(virtualMachineUUID == rhs.virtualMachineUUID))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromRepositoryToDatastore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromRepositoryToDatastore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_copyFromRepositoryToDatastore_pargs {
 public:


  virtual ~Aim_copyFromRepositoryToDatastore_pargs() throw() {}

  const std::string* virtualImageRepositoryPath;
  const std::string* datastorePath;
  const std::string* virtualMachineUUID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_copyFromRepositoryToDatastore_result__isset {
  _Aim_copyFromRepositoryToDatastore_result__isset() : re(false) {}
  bool re;
} _Aim_copyFromRepositoryToDatastore_result__isset;

class Aim_copyFromRepositoryToDatastore_result {
 public:

  Aim_copyFromRepositoryToDatastore_result() {
  }

  virtual ~Aim_copyFromRepositoryToDatastore_result() throw() {}

  RimpException re;

  _Aim_copyFromRepositoryToDatastore_result__isset __isset;

  void __set_re(const RimpException& val) {
    re = val;
  }

  bool operator == (const Aim_copyFromRepositoryToDatastore_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromRepositoryToDatastore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromRepositoryToDatastore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_copyFromRepositoryToDatastore_presult__isset {
  _Aim_copyFromRepositoryToDatastore_presult__isset() : re(false) {}
  bool re;
} _Aim_copyFromRepositoryToDatastore_presult__isset;

class Aim_copyFromRepositoryToDatastore_presult {
 public:


  virtual ~Aim_copyFromRepositoryToDatastore_presult() throw() {}

  RimpException re;

  _Aim_copyFromRepositoryToDatastore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_deleteVirtualImageFromDatastore_args__isset {
  _Aim_deleteVirtualImageFromDatastore_args__isset() : datastorePath(false), virtualMachineUUID(false) {}
  bool datastorePath;
  bool virtualMachineUUID;
} _Aim_deleteVirtualImageFromDatastore_args__isset;

class Aim_deleteVirtualImageFromDatastore_args {
 public:

  Aim_deleteVirtualImageFromDatastore_args() : datastorePath(), virtualMachineUUID() {
  }

  virtual ~Aim_deleteVirtualImageFromDatastore_args() throw() {}

  std::string datastorePath;
  std::string virtualMachineUUID;

  _Aim_deleteVirtualImageFromDatastore_args__isset __isset;

  void __set_datastorePath(const std::string& val) {
    datastorePath = val;
  }

  void __set_virtualMachineUUID(const std::string& val) {
    virtualMachineUUID = val;
  }

  bool operator == (const Aim_deleteVirtualImageFromDatastore_args & rhs) const
  {
    if (!(datastorePath == rhs.datastorePath))
      return false;
    if (!(virtualMachineUUID == rhs.virtualMachineUUID))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVirtualImageFromDatastore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVirtualImageFromDatastore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_deleteVirtualImageFromDatastore_pargs {
 public:


  virtual ~Aim_deleteVirtualImageFromDatastore_pargs() throw() {}

  const std::string* datastorePath;
  const std::string* virtualMachineUUID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_deleteVirtualImageFromDatastore_result__isset {
  _Aim_deleteVirtualImageFromDatastore_result__isset() : re(false) {}
  bool re;
} _Aim_deleteVirtualImageFromDatastore_result__isset;

class Aim_deleteVirtualImageFromDatastore_result {
 public:

  Aim_deleteVirtualImageFromDatastore_result() {
  }

  virtual ~Aim_deleteVirtualImageFromDatastore_result() throw() {}

  RimpException re;

  _Aim_deleteVirtualImageFromDatastore_result__isset __isset;

  void __set_re(const RimpException& val) {
    re = val;
  }

  bool operator == (const Aim_deleteVirtualImageFromDatastore_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVirtualImageFromDatastore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVirtualImageFromDatastore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_deleteVirtualImageFromDatastore_presult__isset {
  _Aim_deleteVirtualImageFromDatastore_presult__isset() : re(false) {}
  bool re;
} _Aim_deleteVirtualImageFromDatastore_presult__isset;

class Aim_deleteVirtualImageFromDatastore_presult {
 public:


  virtual ~Aim_deleteVirtualImageFromDatastore_presult() throw() {}

  RimpException re;

  _Aim_deleteVirtualImageFromDatastore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_copyFromDatastoreToRepository_args__isset {
  _Aim_copyFromDatastoreToRepository_args__isset() : virtualMachineUUID(false), snapshot(false), destinationRepositoryPath(false), sourceDatastorePath(false) {}
  bool virtualMachineUUID;
  bool snapshot;
  bool destinationRepositoryPath;
  bool sourceDatastorePath;
} _Aim_copyFromDatastoreToRepository_args__isset;

class Aim_copyFromDatastoreToRepository_args {
 public:

  Aim_copyFromDatastoreToRepository_args() : virtualMachineUUID(), snapshot(), destinationRepositoryPath(), sourceDatastorePath() {
  }

  virtual ~Aim_copyFromDatastoreToRepository_args() throw() {}

  std::string virtualMachineUUID;
  std::string snapshot;
  std::string destinationRepositoryPath;
  std::string sourceDatastorePath;

  _Aim_copyFromDatastoreToRepository_args__isset __isset;

  void __set_virtualMachineUUID(const std::string& val) {
    virtualMachineUUID = val;
  }

  void __set_snapshot(const std::string& val) {
    snapshot = val;
  }

  void __set_destinationRepositoryPath(const std::string& val) {
    destinationRepositoryPath = val;
  }

  void __set_sourceDatastorePath(const std::string& val) {
    sourceDatastorePath = val;
  }

  bool operator == (const Aim_copyFromDatastoreToRepository_args & rhs) const
  {
    if (!(virtualMachineUUID == rhs.virtualMachineUUID))
      return false;
    if (!(snapshot == rhs.snapshot))
      return false;
    if (!(destinationRepositoryPath == rhs.destinationRepositoryPath))
      return false;
    if (!(sourceDatastorePath == rhs.sourceDatastorePath))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromDatastoreToRepository_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromDatastoreToRepository_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_copyFromDatastoreToRepository_pargs {
 public:


  virtual ~Aim_copyFromDatastoreToRepository_pargs() throw() {}

  const std::string* virtualMachineUUID;
  const std::string* snapshot;
  const std::string* destinationRepositoryPath;
  const std::string* sourceDatastorePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_copyFromDatastoreToRepository_result__isset {
  _Aim_copyFromDatastoreToRepository_result__isset() : re(false) {}
  bool re;
} _Aim_copyFromDatastoreToRepository_result__isset;

class Aim_copyFromDatastoreToRepository_result {
 public:

  Aim_copyFromDatastoreToRepository_result() {
  }

  virtual ~Aim_copyFromDatastoreToRepository_result() throw() {}

  RimpException re;

  _Aim_copyFromDatastoreToRepository_result__isset __isset;

  void __set_re(const RimpException& val) {
    re = val;
  }

  bool operator == (const Aim_copyFromDatastoreToRepository_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromDatastoreToRepository_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromDatastoreToRepository_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_copyFromDatastoreToRepository_presult__isset {
  _Aim_copyFromDatastoreToRepository_presult__isset() : re(false) {}
  bool re;
} _Aim_copyFromDatastoreToRepository_presult__isset;

class Aim_copyFromDatastoreToRepository_presult {
 public:


  virtual ~Aim_copyFromDatastoreToRepository_presult() throw() {}

  RimpException re;

  _Aim_copyFromDatastoreToRepository_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_createVLAN_args__isset {
  _Aim_createVLAN_args__isset() : vlanTag(false), vlanInterface(false), bridgeInterface(false) {}
  bool vlanTag;
  bool vlanInterface;
  bool bridgeInterface;
} _Aim_createVLAN_args__isset;

class Aim_createVLAN_args {
 public:

  Aim_createVLAN_args() : vlanTag(0), vlanInterface(), bridgeInterface() {
  }

  virtual ~Aim_createVLAN_args() throw() {}

  int32_t vlanTag;
  std::string vlanInterface;
  std::string bridgeInterface;

  _Aim_createVLAN_args__isset __isset;

  void __set_vlanTag(const int32_t val) {
    vlanTag = val;
  }

  void __set_vlanInterface(const std::string& val) {
    vlanInterface = val;
  }

  void __set_bridgeInterface(const std::string& val) {
    bridgeInterface = val;
  }

  bool operator == (const Aim_createVLAN_args & rhs) const
  {
    if (!(vlanTag == rhs.vlanTag))
      return false;
    if (!(vlanInterface == rhs.vlanInterface))
      return false;
    if (!(bridgeInterface == rhs.bridgeInterface))
      return false;
    return true;
  }
  bool operator != (const Aim_createVLAN_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createVLAN_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_createVLAN_pargs {
 public:


  virtual ~Aim_createVLAN_pargs() throw() {}

  const int32_t* vlanTag;
  const std::string* vlanInterface;
  const std::string* bridgeInterface;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_createVLAN_result__isset {
  _Aim_createVLAN_result__isset() : ve(false) {}
  bool ve;
} _Aim_createVLAN_result__isset;

class Aim_createVLAN_result {
 public:

  Aim_createVLAN_result() {
  }

  virtual ~Aim_createVLAN_result() throw() {}

  VLanException ve;

  _Aim_createVLAN_result__isset __isset;

  void __set_ve(const VLanException& val) {
    ve = val;
  }

  bool operator == (const Aim_createVLAN_result & rhs) const
  {
    if (!(ve == rhs.ve))
      return false;
    return true;
  }
  bool operator != (const Aim_createVLAN_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createVLAN_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_createVLAN_presult__isset {
  _Aim_createVLAN_presult__isset() : ve(false) {}
  bool ve;
} _Aim_createVLAN_presult__isset;

class Aim_createVLAN_presult {
 public:


  virtual ~Aim_createVLAN_presult() throw() {}

  VLanException ve;

  _Aim_createVLAN_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_deleteVLAN_args__isset {
  _Aim_deleteVLAN_args__isset() : vlanTag(false), vlanInterface(false), bridgeInterface(false) {}
  bool vlanTag;
  bool vlanInterface;
  bool bridgeInterface;
} _Aim_deleteVLAN_args__isset;

class Aim_deleteVLAN_args {
 public:

  Aim_deleteVLAN_args() : vlanTag(0), vlanInterface(), bridgeInterface() {
  }

  virtual ~Aim_deleteVLAN_args() throw() {}

  int32_t vlanTag;
  std::string vlanInterface;
  std::string bridgeInterface;

  _Aim_deleteVLAN_args__isset __isset;

  void __set_vlanTag(const int32_t val) {
    vlanTag = val;
  }

  void __set_vlanInterface(const std::string& val) {
    vlanInterface = val;
  }

  void __set_bridgeInterface(const std::string& val) {
    bridgeInterface = val;
  }

  bool operator == (const Aim_deleteVLAN_args & rhs) const
  {
    if (!(vlanTag == rhs.vlanTag))
      return false;
    if (!(vlanInterface == rhs.vlanInterface))
      return false;
    if (!(bridgeInterface == rhs.bridgeInterface))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVLAN_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVLAN_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_deleteVLAN_pargs {
 public:


  virtual ~Aim_deleteVLAN_pargs() throw() {}

  const int32_t* vlanTag;
  const std::string* vlanInterface;
  const std::string* bridgeInterface;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_deleteVLAN_result__isset {
  _Aim_deleteVLAN_result__isset() : ve(false) {}
  bool ve;
} _Aim_deleteVLAN_result__isset;

class Aim_deleteVLAN_result {
 public:

  Aim_deleteVLAN_result() {
  }

  virtual ~Aim_deleteVLAN_result() throw() {}

  VLanException ve;

  _Aim_deleteVLAN_result__isset __isset;

  void __set_ve(const VLanException& val) {
    ve = val;
  }

  bool operator == (const Aim_deleteVLAN_result & rhs) const
  {
    if (!(ve == rhs.ve))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVLAN_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVLAN_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_deleteVLAN_presult__isset {
  _Aim_deleteVLAN_presult__isset() : ve(false) {}
  bool ve;
} _Aim_deleteVLAN_presult__isset;

class Aim_deleteVLAN_presult {
 public:


  virtual ~Aim_deleteVLAN_presult() throw() {}

  VLanException ve;

  _Aim_deleteVLAN_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Aim_checkVLANConfiguration_args {
 public:

  Aim_checkVLANConfiguration_args() {
  }

  virtual ~Aim_checkVLANConfiguration_args() throw() {}


  bool operator == (const Aim_checkVLANConfiguration_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_checkVLANConfiguration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkVLANConfiguration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_checkVLANConfiguration_pargs {
 public:


  virtual ~Aim_checkVLANConfiguration_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_checkVLANConfiguration_result__isset {
  _Aim_checkVLANConfiguration_result__isset() : ve(false) {}
  bool ve;
} _Aim_checkVLANConfiguration_result__isset;

class Aim_checkVLANConfiguration_result {
 public:

  Aim_checkVLANConfiguration_result() {
  }

  virtual ~Aim_checkVLANConfiguration_result() throw() {}

  VLanException ve;

  _Aim_checkVLANConfiguration_result__isset __isset;

  void __set_ve(const VLanException& val) {
    ve = val;
  }

  bool operator == (const Aim_checkVLANConfiguration_result & rhs) const
  {
    if (!(ve == rhs.ve))
      return false;
    return true;
  }
  bool operator != (const Aim_checkVLANConfiguration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkVLANConfiguration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_checkVLANConfiguration_presult__isset {
  _Aim_checkVLANConfiguration_presult__isset() : ve(false) {}
  bool ve;
} _Aim_checkVLANConfiguration_presult__isset;

class Aim_checkVLANConfiguration_presult {
 public:


  virtual ~Aim_checkVLANConfiguration_presult() throw() {}

  VLanException ve;

  _Aim_checkVLANConfiguration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Aim_getInitiatorIQN_args {
 public:

  Aim_getInitiatorIQN_args() {
  }

  virtual ~Aim_getInitiatorIQN_args() throw() {}


  bool operator == (const Aim_getInitiatorIQN_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getInitiatorIQN_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getInitiatorIQN_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getInitiatorIQN_pargs {
 public:


  virtual ~Aim_getInitiatorIQN_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getInitiatorIQN_result__isset {
  _Aim_getInitiatorIQN_result__isset() : success(false), se(false) {}
  bool success;
  bool se;
} _Aim_getInitiatorIQN_result__isset;

class Aim_getInitiatorIQN_result {
 public:

  Aim_getInitiatorIQN_result() : success() {
  }

  virtual ~Aim_getInitiatorIQN_result() throw() {}

  std::string success;
  StorageException se;

  _Aim_getInitiatorIQN_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_se(const StorageException& val) {
    se = val;
  }

  bool operator == (const Aim_getInitiatorIQN_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(se == rhs.se))
      return false;
    return true;
  }
  bool operator != (const Aim_getInitiatorIQN_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getInitiatorIQN_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getInitiatorIQN_presult__isset {
  _Aim_getInitiatorIQN_presult__isset() : success(false), se(false) {}
  bool success;
  bool se;
} _Aim_getInitiatorIQN_presult__isset;

class Aim_getInitiatorIQN_presult {
 public:


  virtual ~Aim_getInitiatorIQN_presult() throw() {}

  std::string* success;
  StorageException se;

  _Aim_getInitiatorIQN_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_rescanISCSI_args__isset {
  _Aim_rescanISCSI_args__isset() : targets(false) {}
  bool targets;
} _Aim_rescanISCSI_args__isset;

class Aim_rescanISCSI_args {
 public:

  Aim_rescanISCSI_args() {
  }

  virtual ~Aim_rescanISCSI_args() throw() {}

  std::vector<std::string>  targets;

  _Aim_rescanISCSI_args__isset __isset;

  void __set_targets(const std::vector<std::string> & val) {
    targets = val;
  }

  bool operator == (const Aim_rescanISCSI_args & rhs) const
  {
    if (!(targets == rhs.targets))
      return false;
    return true;
  }
  bool operator != (const Aim_rescanISCSI_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_rescanISCSI_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_rescanISCSI_pargs {
 public:


  virtual ~Aim_rescanISCSI_pargs() throw() {}

  const std::vector<std::string> * targets;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_rescanISCSI_result__isset {
  _Aim_rescanISCSI_result__isset() : se(false) {}
  bool se;
} _Aim_rescanISCSI_result__isset;

class Aim_rescanISCSI_result {
 public:

  Aim_rescanISCSI_result() {
  }

  virtual ~Aim_rescanISCSI_result() throw() {}

  StorageException se;

  _Aim_rescanISCSI_result__isset __isset;

  void __set_se(const StorageException& val) {
    se = val;
  }

  bool operator == (const Aim_rescanISCSI_result & rhs) const
  {
    if (!(se == rhs.se))
      return false;
    return true;
  }
  bool operator != (const Aim_rescanISCSI_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_rescanISCSI_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_rescanISCSI_presult__isset {
  _Aim_rescanISCSI_presult__isset() : se(false) {}
  bool se;
} _Aim_rescanISCSI_presult__isset;

class Aim_rescanISCSI_presult {
 public:


  virtual ~Aim_rescanISCSI_presult() throw() {}

  StorageException se;

  _Aim_rescanISCSI_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Aim_getNodeInfo_args {
 public:

  Aim_getNodeInfo_args() {
  }

  virtual ~Aim_getNodeInfo_args() throw() {}


  bool operator == (const Aim_getNodeInfo_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getNodeInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNodeInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getNodeInfo_pargs {
 public:


  virtual ~Aim_getNodeInfo_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getNodeInfo_result__isset {
  _Aim_getNodeInfo_result__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getNodeInfo_result__isset;

class Aim_getNodeInfo_result {
 public:

  Aim_getNodeInfo_result() {
  }

  virtual ~Aim_getNodeInfo_result() throw() {}

  NodeInfo success;
  LibvirtException libvirtException;

  _Aim_getNodeInfo_result__isset __isset;

  void __set_success(const NodeInfo& val) {
    success = val;
  }

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_getNodeInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getNodeInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNodeInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getNodeInfo_presult__isset {
  _Aim_getNodeInfo_presult__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getNodeInfo_presult__isset;

class Aim_getNodeInfo_presult {
 public:


  virtual ~Aim_getNodeInfo_presult() throw() {}

  NodeInfo* success;
  LibvirtException libvirtException;

  _Aim_getNodeInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Aim_getDomains_args {
 public:

  Aim_getDomains_args() {
  }

  virtual ~Aim_getDomains_args() throw() {}


  bool operator == (const Aim_getDomains_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getDomains_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomains_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getDomains_pargs {
 public:


  virtual ~Aim_getDomains_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDomains_result__isset {
  _Aim_getDomains_result__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getDomains_result__isset;

class Aim_getDomains_result {
 public:

  Aim_getDomains_result() {
  }

  virtual ~Aim_getDomains_result() throw() {}

  std::vector<DomainInfo>  success;
  LibvirtException libvirtException;

  _Aim_getDomains_result__isset __isset;

  void __set_success(const std::vector<DomainInfo> & val) {
    success = val;
  }

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_getDomains_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomains_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomains_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDomains_presult__isset {
  _Aim_getDomains_presult__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getDomains_presult__isset;

class Aim_getDomains_presult {
 public:


  virtual ~Aim_getDomains_presult() throw() {}

  std::vector<DomainInfo> * success;
  LibvirtException libvirtException;

  _Aim_getDomains_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_defineDomain_args__isset {
  _Aim_defineDomain_args__isset() : xmlDesc(false) {}
  bool xmlDesc;
} _Aim_defineDomain_args__isset;

class Aim_defineDomain_args {
 public:

  Aim_defineDomain_args() : xmlDesc() {
  }

  virtual ~Aim_defineDomain_args() throw() {}

  std::string xmlDesc;

  _Aim_defineDomain_args__isset __isset;

  void __set_xmlDesc(const std::string& val) {
    xmlDesc = val;
  }

  bool operator == (const Aim_defineDomain_args & rhs) const
  {
    if (!(xmlDesc == rhs.xmlDesc))
      return false;
    return true;
  }
  bool operator != (const Aim_defineDomain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_defineDomain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_defineDomain_pargs {
 public:


  virtual ~Aim_defineDomain_pargs() throw() {}

  const std::string* xmlDesc;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_defineDomain_result__isset {
  _Aim_defineDomain_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_defineDomain_result__isset;

class Aim_defineDomain_result {
 public:

  Aim_defineDomain_result() {
  }

  virtual ~Aim_defineDomain_result() throw() {}

  LibvirtException libvirtException;

  _Aim_defineDomain_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_defineDomain_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_defineDomain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_defineDomain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_defineDomain_presult__isset {
  _Aim_defineDomain_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_defineDomain_presult__isset;

class Aim_defineDomain_presult {
 public:


  virtual ~Aim_defineDomain_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_defineDomain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_undefineDomain_args__isset {
  _Aim_undefineDomain_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_undefineDomain_args__isset;

class Aim_undefineDomain_args {
 public:

  Aim_undefineDomain_args() : domainName() {
  }

  virtual ~Aim_undefineDomain_args() throw() {}

  std::string domainName;

  _Aim_undefineDomain_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_undefineDomain_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_undefineDomain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_undefineDomain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_undefineDomain_pargs {
 public:


  virtual ~Aim_undefineDomain_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_undefineDomain_result__isset {
  _Aim_undefineDomain_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_undefineDomain_result__isset;

class Aim_undefineDomain_result {
 public:

  Aim_undefineDomain_result() {
  }

  virtual ~Aim_undefineDomain_result() throw() {}

  LibvirtException libvirtException;

  _Aim_undefineDomain_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_undefineDomain_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_undefineDomain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_undefineDomain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_undefineDomain_presult__isset {
  _Aim_undefineDomain_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_undefineDomain_presult__isset;

class Aim_undefineDomain_presult {
 public:


  virtual ~Aim_undefineDomain_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_undefineDomain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_existDomain_args__isset {
  _Aim_existDomain_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_existDomain_args__isset;

class Aim_existDomain_args {
 public:

  Aim_existDomain_args() : domainName() {
  }

  virtual ~Aim_existDomain_args() throw() {}

  std::string domainName;

  _Aim_existDomain_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_existDomain_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_existDomain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_existDomain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_existDomain_pargs {
 public:


  virtual ~Aim_existDomain_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_existDomain_result__isset {
  _Aim_existDomain_result__isset() : success(false) {}
  bool success;
} _Aim_existDomain_result__isset;

class Aim_existDomain_result {
 public:

  Aim_existDomain_result() : success(0) {
  }

  virtual ~Aim_existDomain_result() throw() {}

  bool success;

  _Aim_existDomain_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const Aim_existDomain_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Aim_existDomain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_existDomain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_existDomain_presult__isset {
  _Aim_existDomain_presult__isset() : success(false) {}
  bool success;
} _Aim_existDomain_presult__isset;

class Aim_existDomain_presult {
 public:


  virtual ~Aim_existDomain_presult() throw() {}

  bool* success;

  _Aim_existDomain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_getDomainState_args__isset {
  _Aim_getDomainState_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_getDomainState_args__isset;

class Aim_getDomainState_args {
 public:

  Aim_getDomainState_args() : domainName() {
  }

  virtual ~Aim_getDomainState_args() throw() {}

  std::string domainName;

  _Aim_getDomainState_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_getDomainState_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getDomainState_pargs {
 public:


  virtual ~Aim_getDomainState_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDomainState_result__isset {
  _Aim_getDomainState_result__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getDomainState_result__isset;

class Aim_getDomainState_result {
 public:

  Aim_getDomainState_result() : success((DomainState::type)0) {
  }

  virtual ~Aim_getDomainState_result() throw() {}

  DomainState::type success;
  LibvirtException libvirtException;

  _Aim_getDomainState_result__isset __isset;

  void __set_success(const DomainState::type val) {
    success = val;
  }

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_getDomainState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDomainState_presult__isset {
  _Aim_getDomainState_presult__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getDomainState_presult__isset;

class Aim_getDomainState_presult {
 public:


  virtual ~Aim_getDomainState_presult() throw() {}

  DomainState::type* success;
  LibvirtException libvirtException;

  _Aim_getDomainState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_getDomainInfo_args__isset {
  _Aim_getDomainInfo_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_getDomainInfo_args__isset;

class Aim_getDomainInfo_args {
 public:

  Aim_getDomainInfo_args() : domainName() {
  }

  virtual ~Aim_getDomainInfo_args() throw() {}

  std::string domainName;

  _Aim_getDomainInfo_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_getDomainInfo_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_getDomainInfo_pargs {
 public:


  virtual ~Aim_getDomainInfo_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDomainInfo_result__isset {
  _Aim_getDomainInfo_result__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getDomainInfo_result__isset;

class Aim_getDomainInfo_result {
 public:

  Aim_getDomainInfo_result() {
  }

  virtual ~Aim_getDomainInfo_result() throw() {}

  DomainInfo success;
  LibvirtException libvirtException;

  _Aim_getDomainInfo_result__isset __isset;

  void __set_success(const DomainInfo& val) {
    success = val;
  }

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_getDomainInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_getDomainInfo_presult__isset {
  _Aim_getDomainInfo_presult__isset() : success(false), libvirtException(false) {}
  bool success;
  bool libvirtException;
} _Aim_getDomainInfo_presult__isset;

class Aim_getDomainInfo_presult {
 public:


  virtual ~Aim_getDomainInfo_presult() throw() {}

  DomainInfo* success;
  LibvirtException libvirtException;

  _Aim_getDomainInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_powerOn_args__isset {
  _Aim_powerOn_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_powerOn_args__isset;

class Aim_powerOn_args {
 public:

  Aim_powerOn_args() : domainName() {
  }

  virtual ~Aim_powerOn_args() throw() {}

  std::string domainName;

  _Aim_powerOn_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_powerOn_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOn_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOn_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_powerOn_pargs {
 public:


  virtual ~Aim_powerOn_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_powerOn_result__isset {
  _Aim_powerOn_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_powerOn_result__isset;

class Aim_powerOn_result {
 public:

  Aim_powerOn_result() {
  }

  virtual ~Aim_powerOn_result() throw() {}

  LibvirtException libvirtException;

  _Aim_powerOn_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_powerOn_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOn_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOn_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_powerOn_presult__isset {
  _Aim_powerOn_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_powerOn_presult__isset;

class Aim_powerOn_presult {
 public:


  virtual ~Aim_powerOn_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_powerOn_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_powerOff_args__isset {
  _Aim_powerOff_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_powerOff_args__isset;

class Aim_powerOff_args {
 public:

  Aim_powerOff_args() : domainName() {
  }

  virtual ~Aim_powerOff_args() throw() {}

  std::string domainName;

  _Aim_powerOff_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_powerOff_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOff_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOff_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_powerOff_pargs {
 public:


  virtual ~Aim_powerOff_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_powerOff_result__isset {
  _Aim_powerOff_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_powerOff_result__isset;

class Aim_powerOff_result {
 public:

  Aim_powerOff_result() {
  }

  virtual ~Aim_powerOff_result() throw() {}

  LibvirtException libvirtException;

  _Aim_powerOff_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_powerOff_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOff_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOff_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_powerOff_presult__isset {
  _Aim_powerOff_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_powerOff_presult__isset;

class Aim_powerOff_presult {
 public:


  virtual ~Aim_powerOff_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_powerOff_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_reset_args__isset {
  _Aim_reset_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_reset_args__isset;

class Aim_reset_args {
 public:

  Aim_reset_args() : domainName() {
  }

  virtual ~Aim_reset_args() throw() {}

  std::string domainName;

  _Aim_reset_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_reset_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_reset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_reset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_reset_pargs {
 public:


  virtual ~Aim_reset_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_reset_result__isset {
  _Aim_reset_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_reset_result__isset;

class Aim_reset_result {
 public:

  Aim_reset_result() {
  }

  virtual ~Aim_reset_result() throw() {}

  LibvirtException libvirtException;

  _Aim_reset_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_reset_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_reset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_reset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_reset_presult__isset {
  _Aim_reset_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_reset_presult__isset;

class Aim_reset_presult {
 public:


  virtual ~Aim_reset_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_reset_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_pause_args__isset {
  _Aim_pause_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_pause_args__isset;

class Aim_pause_args {
 public:

  Aim_pause_args() : domainName() {
  }

  virtual ~Aim_pause_args() throw() {}

  std::string domainName;

  _Aim_pause_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_pause_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_pause_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_pause_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_pause_pargs {
 public:


  virtual ~Aim_pause_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_pause_result__isset {
  _Aim_pause_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_pause_result__isset;

class Aim_pause_result {
 public:

  Aim_pause_result() {
  }

  virtual ~Aim_pause_result() throw() {}

  LibvirtException libvirtException;

  _Aim_pause_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_pause_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_pause_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_pause_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_pause_presult__isset {
  _Aim_pause_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_pause_presult__isset;

class Aim_pause_presult {
 public:


  virtual ~Aim_pause_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_pause_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_resume_args__isset {
  _Aim_resume_args__isset() : domainName(false) {}
  bool domainName;
} _Aim_resume_args__isset;

class Aim_resume_args {
 public:

  Aim_resume_args() : domainName() {
  }

  virtual ~Aim_resume_args() throw() {}

  std::string domainName;

  _Aim_resume_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  bool operator == (const Aim_resume_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_resume_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resume_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_resume_pargs {
 public:


  virtual ~Aim_resume_pargs() throw() {}

  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_resume_result__isset {
  _Aim_resume_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_resume_result__isset;

class Aim_resume_result {
 public:

  Aim_resume_result() {
  }

  virtual ~Aim_resume_result() throw() {}

  LibvirtException libvirtException;

  _Aim_resume_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_resume_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_resume_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resume_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_resume_presult__isset {
  _Aim_resume_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_resume_presult__isset;

class Aim_resume_presult {
 public:


  virtual ~Aim_resume_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_resume_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_createISCSIStoragePool_args__isset {
  _Aim_createISCSIStoragePool_args__isset() : xmlDesc(false) {}
  bool xmlDesc;
} _Aim_createISCSIStoragePool_args__isset;

class Aim_createISCSIStoragePool_args {
 public:

  Aim_createISCSIStoragePool_args() : xmlDesc() {
  }

  virtual ~Aim_createISCSIStoragePool_args() throw() {}

  std::string xmlDesc;

  _Aim_createISCSIStoragePool_args__isset __isset;

  void __set_xmlDesc(const std::string& val) {
    xmlDesc = val;
  }

  bool operator == (const Aim_createISCSIStoragePool_args & rhs) const
  {
    if (!(xmlDesc == rhs.xmlDesc))
      return false;
    return true;
  }
  bool operator != (const Aim_createISCSIStoragePool_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createISCSIStoragePool_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_createISCSIStoragePool_pargs {
 public:


  virtual ~Aim_createISCSIStoragePool_pargs() throw() {}

  const std::string* xmlDesc;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_createISCSIStoragePool_result__isset {
  _Aim_createISCSIStoragePool_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_createISCSIStoragePool_result__isset;

class Aim_createISCSIStoragePool_result {
 public:

  Aim_createISCSIStoragePool_result() {
  }

  virtual ~Aim_createISCSIStoragePool_result() throw() {}

  LibvirtException libvirtException;

  _Aim_createISCSIStoragePool_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_createISCSIStoragePool_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_createISCSIStoragePool_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createISCSIStoragePool_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_createISCSIStoragePool_presult__isset {
  _Aim_createISCSIStoragePool_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_createISCSIStoragePool_presult__isset;

class Aim_createISCSIStoragePool_presult {
 public:


  virtual ~Aim_createISCSIStoragePool_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_createISCSIStoragePool_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_createNFSStoragePool_args__isset {
  _Aim_createNFSStoragePool_args__isset() : xmlDesc(false) {}
  bool xmlDesc;
} _Aim_createNFSStoragePool_args__isset;

class Aim_createNFSStoragePool_args {
 public:

  Aim_createNFSStoragePool_args() : xmlDesc() {
  }

  virtual ~Aim_createNFSStoragePool_args() throw() {}

  std::string xmlDesc;

  _Aim_createNFSStoragePool_args__isset __isset;

  void __set_xmlDesc(const std::string& val) {
    xmlDesc = val;
  }

  bool operator == (const Aim_createNFSStoragePool_args & rhs) const
  {
    if (!(xmlDesc == rhs.xmlDesc))
      return false;
    return true;
  }
  bool operator != (const Aim_createNFSStoragePool_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createNFSStoragePool_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_createNFSStoragePool_pargs {
 public:


  virtual ~Aim_createNFSStoragePool_pargs() throw() {}

  const std::string* xmlDesc;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_createNFSStoragePool_result__isset {
  _Aim_createNFSStoragePool_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_createNFSStoragePool_result__isset;

class Aim_createNFSStoragePool_result {
 public:

  Aim_createNFSStoragePool_result() {
  }

  virtual ~Aim_createNFSStoragePool_result() throw() {}

  LibvirtException libvirtException;

  _Aim_createNFSStoragePool_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_createNFSStoragePool_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_createNFSStoragePool_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createNFSStoragePool_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_createNFSStoragePool_presult__isset {
  _Aim_createNFSStoragePool_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_createNFSStoragePool_presult__isset;

class Aim_createNFSStoragePool_presult {
 public:


  virtual ~Aim_createNFSStoragePool_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_createNFSStoragePool_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Aim_resizeDisk_args__isset {
  _Aim_resizeDisk_args__isset() : domainName(false), diskPath(false), diskSizeInKb(false) {}
  bool domainName;
  bool diskPath;
  bool diskSizeInKb;
} _Aim_resizeDisk_args__isset;

class Aim_resizeDisk_args {
 public:

  Aim_resizeDisk_args() : domainName(), diskPath(), diskSizeInKb(0) {
  }

  virtual ~Aim_resizeDisk_args() throw() {}

  std::string domainName;
  std::string diskPath;
  double diskSizeInKb;

  _Aim_resizeDisk_args__isset __isset;

  void __set_domainName(const std::string& val) {
    domainName = val;
  }

  void __set_diskPath(const std::string& val) {
    diskPath = val;
  }

  void __set_diskSizeInKb(const double val) {
    diskSizeInKb = val;
  }

  bool operator == (const Aim_resizeDisk_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    if (!(diskPath == rhs.diskPath))
      return false;
    if (!(diskSizeInKb == rhs.diskSizeInKb))
      return false;
    return true;
  }
  bool operator != (const Aim_resizeDisk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resizeDisk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Aim_resizeDisk_pargs {
 public:


  virtual ~Aim_resizeDisk_pargs() throw() {}

  const std::string* domainName;
  const std::string* diskPath;
  const double* diskSizeInKb;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_resizeDisk_result__isset {
  _Aim_resizeDisk_result__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_resizeDisk_result__isset;

class Aim_resizeDisk_result {
 public:

  Aim_resizeDisk_result() {
  }

  virtual ~Aim_resizeDisk_result() throw() {}

  LibvirtException libvirtException;

  _Aim_resizeDisk_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val) {
    libvirtException = val;
  }

  bool operator == (const Aim_resizeDisk_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_resizeDisk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resizeDisk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Aim_resizeDisk_presult__isset {
  _Aim_resizeDisk_presult__isset() : libvirtException(false) {}
  bool libvirtException;
} _Aim_resizeDisk_presult__isset;

class Aim_resizeDisk_presult {
 public:


  virtual ~Aim_resizeDisk_presult() throw() {}

  LibvirtException libvirtException;

  _Aim_resizeDisk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class AimClient : virtual public AimIf {
 public:
  AimClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  AimClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void checkRimpConfiguration();
  void send_checkRimpConfiguration();
  void recv_checkRimpConfiguration();
  int64_t getDiskFileSize(const std::string& virtualImageDatastorePath);
  void send_getDiskFileSize(const std::string& virtualImageDatastorePath);
  int64_t recv_getDiskFileSize();
  void getDatastores(std::vector<Datastore> & _return);
  void send_getDatastores();
  void recv_getDatastores(std::vector<Datastore> & _return);
  void getNetInterfaces(std::vector<NetInterface> & _return);
  void send_getNetInterfaces();
  void recv_getNetInterfaces(std::vector<NetInterface> & _return);
  void copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID);
  void send_copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID);
  void recv_copyFromRepositoryToDatastore();
  void deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID);
  void send_deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID);
  void recv_deleteVirtualImageFromDatastore();
  void copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath);
  void send_copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath);
  void recv_copyFromDatastoreToRepository();
  void createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void send_createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void recv_createVLAN();
  void deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void send_deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void recv_deleteVLAN();
  void checkVLANConfiguration();
  void send_checkVLANConfiguration();
  void recv_checkVLANConfiguration();
  void getInitiatorIQN(std::string& _return);
  void send_getInitiatorIQN();
  void recv_getInitiatorIQN(std::string& _return);
  void rescanISCSI(const std::vector<std::string> & targets);
  void send_rescanISCSI(const std::vector<std::string> & targets);
  void recv_rescanISCSI();
  void getNodeInfo(NodeInfo& _return);
  void send_getNodeInfo();
  void recv_getNodeInfo(NodeInfo& _return);
  void getDomains(std::vector<DomainInfo> & _return);
  void send_getDomains();
  void recv_getDomains(std::vector<DomainInfo> & _return);
  void defineDomain(const std::string& xmlDesc);
  void send_defineDomain(const std::string& xmlDesc);
  void recv_defineDomain();
  void undefineDomain(const std::string& domainName);
  void send_undefineDomain(const std::string& domainName);
  void recv_undefineDomain();
  bool existDomain(const std::string& domainName);
  void send_existDomain(const std::string& domainName);
  bool recv_existDomain();
  DomainState::type getDomainState(const std::string& domainName);
  void send_getDomainState(const std::string& domainName);
  DomainState::type recv_getDomainState();
  void getDomainInfo(DomainInfo& _return, const std::string& domainName);
  void send_getDomainInfo(const std::string& domainName);
  void recv_getDomainInfo(DomainInfo& _return);
  void powerOn(const std::string& domainName);
  void send_powerOn(const std::string& domainName);
  void recv_powerOn();
  void powerOff(const std::string& domainName);
  void send_powerOff(const std::string& domainName);
  void recv_powerOff();
  void reset(const std::string& domainName);
  void send_reset(const std::string& domainName);
  void recv_reset();
  void pause(const std::string& domainName);
  void send_pause(const std::string& domainName);
  void recv_pause();
  void resume(const std::string& domainName);
  void send_resume(const std::string& domainName);
  void recv_resume();
  void createISCSIStoragePool(const std::string& xmlDesc);
  void send_createISCSIStoragePool(const std::string& xmlDesc);
  void recv_createISCSIStoragePool();
  void createNFSStoragePool(const std::string& xmlDesc);
  void send_createNFSStoragePool(const std::string& xmlDesc);
  void recv_createNFSStoragePool();
  void resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb);
  void send_resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb);
  void recv_resizeDisk();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class AimProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<AimIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (AimProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_checkRimpConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDiskFileSize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDatastores(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNetInterfaces(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_copyFromRepositoryToDatastore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteVirtualImageFromDatastore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_copyFromDatastoreToRepository(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createVLAN(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteVLAN(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkVLANConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getInitiatorIQN(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rescanISCSI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNodeInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDomains(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_defineDomain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_undefineDomain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_existDomain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDomainState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDomainInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_powerOn(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_powerOff(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pause(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resume(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createISCSIStoragePool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createNFSStoragePool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resizeDisk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  AimProcessor(boost::shared_ptr<AimIf> iface) :
    iface_(iface) {
    processMap_["checkRimpConfiguration"] = &AimProcessor::process_checkRimpConfiguration;
    processMap_["getDiskFileSize"] = &AimProcessor::process_getDiskFileSize;
    processMap_["getDatastores"] = &AimProcessor::process_getDatastores;
    processMap_["getNetInterfaces"] = &AimProcessor::process_getNetInterfaces;
    processMap_["copyFromRepositoryToDatastore"] = &AimProcessor::process_copyFromRepositoryToDatastore;
    processMap_["deleteVirtualImageFromDatastore"] = &AimProcessor::process_deleteVirtualImageFromDatastore;
    processMap_["copyFromDatastoreToRepository"] = &AimProcessor::process_copyFromDatastoreToRepository;
    processMap_["createVLAN"] = &AimProcessor::process_createVLAN;
    processMap_["deleteVLAN"] = &AimProcessor::process_deleteVLAN;
    processMap_["checkVLANConfiguration"] = &AimProcessor::process_checkVLANConfiguration;
    processMap_["getInitiatorIQN"] = &AimProcessor::process_getInitiatorIQN;
    processMap_["rescanISCSI"] = &AimProcessor::process_rescanISCSI;
    processMap_["getNodeInfo"] = &AimProcessor::process_getNodeInfo;
    processMap_["getDomains"] = &AimProcessor::process_getDomains;
    processMap_["defineDomain"] = &AimProcessor::process_defineDomain;
    processMap_["undefineDomain"] = &AimProcessor::process_undefineDomain;
    processMap_["existDomain"] = &AimProcessor::process_existDomain;
    processMap_["getDomainState"] = &AimProcessor::process_getDomainState;
    processMap_["getDomainInfo"] = &AimProcessor::process_getDomainInfo;
    processMap_["powerOn"] = &AimProcessor::process_powerOn;
    processMap_["powerOff"] = &AimProcessor::process_powerOff;
    processMap_["reset"] = &AimProcessor::process_reset;
    processMap_["pause"] = &AimProcessor::process_pause;
    processMap_["resume"] = &AimProcessor::process_resume;
    processMap_["createISCSIStoragePool"] = &AimProcessor::process_createISCSIStoragePool;
    processMap_["createNFSStoragePool"] = &AimProcessor::process_createNFSStoragePool;
    processMap_["resizeDisk"] = &AimProcessor::process_resizeDisk;
  }

  virtual ~AimProcessor() {}
};

class AimProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  AimProcessorFactory(const ::boost::shared_ptr< AimIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< AimIfFactory > handlerFactory_;
};

class AimMultiface : virtual public AimIf {
 public:
  AimMultiface(std::vector<boost::shared_ptr<AimIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~AimMultiface() {}
 protected:
  std::vector<boost::shared_ptr<AimIf> > ifaces_;
  AimMultiface() {}
  void add(boost::shared_ptr<AimIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void checkRimpConfiguration() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->checkRimpConfiguration();
    }
    ifaces_[i]->checkRimpConfiguration();
  }

  int64_t getDiskFileSize(const std::string& virtualImageDatastorePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDiskFileSize(virtualImageDatastorePath);
    }
    return ifaces_[i]->getDiskFileSize(virtualImageDatastorePath);
  }

  void getDatastores(std::vector<Datastore> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDatastores(_return);
    }
    ifaces_[i]->getDatastores(_return);
    return;
  }

  void getNetInterfaces(std::vector<NetInterface> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNetInterfaces(_return);
    }
    ifaces_[i]->getNetInterfaces(_return);
    return;
  }

  void copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->copyFromRepositoryToDatastore(virtualImageRepositoryPath, datastorePath, virtualMachineUUID);
    }
    ifaces_[i]->copyFromRepositoryToDatastore(virtualImageRepositoryPath, datastorePath, virtualMachineUUID);
  }

  void deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteVirtualImageFromDatastore(datastorePath, virtualMachineUUID);
    }
    ifaces_[i]->deleteVirtualImageFromDatastore(datastorePath, virtualMachineUUID);
  }

  void copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->copyFromDatastoreToRepository(virtualMachineUUID, snapshot, destinationRepositoryPath, sourceDatastorePath);
    }
    ifaces_[i]->copyFromDatastoreToRepository(virtualMachineUUID, snapshot, destinationRepositoryPath, sourceDatastorePath);
  }

  void createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createVLAN(vlanTag, vlanInterface, bridgeInterface);
    }
    ifaces_[i]->createVLAN(vlanTag, vlanInterface, bridgeInterface);
  }

  void deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteVLAN(vlanTag, vlanInterface, bridgeInterface);
    }
    ifaces_[i]->deleteVLAN(vlanTag, vlanInterface, bridgeInterface);
  }

  void checkVLANConfiguration() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->checkVLANConfiguration();
    }
    ifaces_[i]->checkVLANConfiguration();
  }

  void getInitiatorIQN(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getInitiatorIQN(_return);
    }
    ifaces_[i]->getInitiatorIQN(_return);
    return;
  }

  void rescanISCSI(const std::vector<std::string> & targets) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rescanISCSI(targets);
    }
    ifaces_[i]->rescanISCSI(targets);
  }

  void getNodeInfo(NodeInfo& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNodeInfo(_return);
    }
    ifaces_[i]->getNodeInfo(_return);
    return;
  }

  void getDomains(std::vector<DomainInfo> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDomains(_return);
    }
    ifaces_[i]->getDomains(_return);
    return;
  }

  void defineDomain(const std::string& xmlDesc) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->defineDomain(xmlDesc);
    }
    ifaces_[i]->defineDomain(xmlDesc);
  }

  void undefineDomain(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->undefineDomain(domainName);
    }
    ifaces_[i]->undefineDomain(domainName);
  }

  bool existDomain(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->existDomain(domainName);
    }
    return ifaces_[i]->existDomain(domainName);
  }

  DomainState::type getDomainState(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDomainState(domainName);
    }
    return ifaces_[i]->getDomainState(domainName);
  }

  void getDomainInfo(DomainInfo& _return, const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDomainInfo(_return, domainName);
    }
    ifaces_[i]->getDomainInfo(_return, domainName);
    return;
  }

  void powerOn(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->powerOn(domainName);
    }
    ifaces_[i]->powerOn(domainName);
  }

  void powerOff(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->powerOff(domainName);
    }
    ifaces_[i]->powerOff(domainName);
  }

  void reset(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->reset(domainName);
    }
    ifaces_[i]->reset(domainName);
  }

  void pause(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pause(domainName);
    }
    ifaces_[i]->pause(domainName);
  }

  void resume(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resume(domainName);
    }
    ifaces_[i]->resume(domainName);
  }

  void createISCSIStoragePool(const std::string& xmlDesc) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createISCSIStoragePool(xmlDesc);
    }
    ifaces_[i]->createISCSIStoragePool(xmlDesc);
  }

  void createNFSStoragePool(const std::string& xmlDesc) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createNFSStoragePool(xmlDesc);
    }
    ifaces_[i]->createNFSStoragePool(xmlDesc);
  }

  void resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resizeDisk(domainName, diskPath, diskSizeInKb);
    }
    ifaces_[i]->resizeDisk(domainName, diskPath, diskSizeInKb);
  }

};



#endif
